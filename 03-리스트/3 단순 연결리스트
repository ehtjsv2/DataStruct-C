 <배운점>
 
 -연결리스트 메모리 해제 시.
 헤드만 free하면 안되고 노드 하나하나 다 free해주어야한다.
 
 -strcpy() 주의점
 strcpy는 문장끝에 '\0'을 넣어주지 않기때문에 조심해야한다.
 ------------------------------------------------------------------------------------------------------------------------------------
 <코드>
 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>


// 공백 연결리스트를 생성
// 연결리스트 전체 메모리 해제
// 연결리스트 순서대로 출력
// 노드를 중간에 삽입
// 마지막 노드로 삽입
// 노드 입력 후 노드를 삭제
// 노드를 탐색 후 노드 리턴

typedef struct ListNode { //노드 구조체
	char data[4];
	struct Node* link;
}listNode;

typedef struct linkedList_h { // 리스트의 헤드
	listNode* head;
}linkedList_h;

linkedList_h* Create_List() { // 공백 연결리스트 생성
	linkedList_h* newlist = (linkedList_h*)malloc(sizeof(linkedList_h));
	newlist->head = NULL;
	return newlist;
}

void freeList(linkedList_h* L) { //연결리스트 전체메모리 해제
	listNode* p;
	while (L->head != NULL) {
		p = L->head;
		L->head = L->head->link;
		free(p);
		p = NULL;
	}
	return;
}

void insertFirstNode(linkedList_h* L, char* data) {
	listNode* node = (listNode*)malloc(sizeof(listNode));
	strcpy(node->data, data); // node->data 에 문장끝에는 0이 아니라 쓰레기값이 들어있어서 출력할 때 문제를 일으킬수 있기때문에 끝에0을 넣어줌
	node->data[strlen(data)] = '\0';
	node->link = L->head;
	L->head = node;
	return;
}

void printList(linkedList_h* L) { // 연결리스트 순서대로 출력
	listNode* horse = L->head;
	while (horse != NULL) {
		printf("%s ->", horse->data);
		horse = horse->link;
	}
	puts("");
	return;
}

void main() {
	linkedList_h* L = Create_List();	// 공백리스트 생성
	insertFirstNode(L, "월");	// 첫번째 노드로 삽입
	printList(L);	//리스트 출력
}
------------------------------------------------------------------------------------------------------------------------------------
<출력>
월 ->

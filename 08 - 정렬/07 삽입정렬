<배운점>

-삽입정렬이란
// 안정 정렬이다.(stable sort)
// 제자리 정렬(in-place sort)
// 거의 정렬된 상태(Nearly Sorted)의 배열을 정렬할 때 매우 효율적이다.
앞에서부터 차례대로 이미 정렬된 배열 부분과 비교해 원소를 한개씩 그 원소의 위치에 맞는 자리에 삽입해주는 정렬이라고 보면된다.
오른쪽 끝 원소부터 새로 넣은 원소랑 비교하며 새로운 원소보다 크다면 한칸씩 오른쪽으로 밀어주면 된다.

-시간복잡도
최선 : O(N)
평균 : O(N^2)
최악 : O(N^2)

-아쉬운점
새로운 원소를 넣을때 큰것을 만날때 마다 스왑을 해줬는데, 교재를 보니 이것은 살짝 비효율적이다.
큰것을 만나면 그 큰원소만 오른쪽으로 밀어주고 계속 그렇게하다가 자기 자리를 찾으면 새로운 원소를 삽입해주면서 끝내면 더 효율적일 것이다.


------------------------------------------------------------------------------------------------------------------------------
<코드>

#include <stdio.h>
#include <stdlib.h>

void swap(int arr[],int i, int j) {
	int tmp;
	tmp = arr[i];
	arr[i] = arr[j];
	arr[j] = tmp;
	return;
}

printArr(int arr[], int len) {
	for (int i = 0; i < len; i++) {
		printf("%d ", arr[i]);
	}
	printf("\n");
}

void sellectionSort(int arr[], int len) {	// begin은 제일 왼쪽 원소 인덱스 , end는 제일 오른쪽 원소 인덱스
	for (int i = 0; i < len-1; i++) {
		for (int j = i; j >= 0; j--) {
			if (arr[j + 1] < arr[j]) {
				swap(arr, j+1, j);
			}
		}
		printf("%d 번째 : ",i+1);
		printArr(arr, len);
	}
}

main() {
	int arr[] = { 69,10,30,2,16,8,31,22 };
	int len = sizeof(arr) / sizeof(int);

	printArr(arr, len);
	sellectionSort(arr,len);
	puts("");
	printArr(arr, len);
}

------------------------------------------------------------------------------------------------------------------------------
<출력>

69 10 30 2 16 8 31 22
1 번째 : 10 69 30 2 16 8 31 22
2 번째 : 10 30 69 2 16 8 31 22
3 번째 : 2 10 30 69 16 8 31 22
4 번째 : 2 10 16 30 69 8 31 22
5 번째 : 2 8 10 16 30 69 31 22
6 번째 : 2 8 10 16 30 31 69 22
7 번째 : 2 8 10 16 22 30 31 69

2 8 10 16 22 30 31 69
